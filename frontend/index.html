<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ZenChess</title>

  <link rel="stylesheet" href="https://unpkg.com/chessground@8.3.11/assets/chessground.base.css">
  <link rel="stylesheet" href="https://unpkg.com/chessground@8.3.11/assets/chessground.brown.css">
  <link rel="stylesheet" href="https://unpkg.com/chessground@8.3.11/assets/chessground.cburnett.css">
  <style>

    /* --- Base Theme Colors --- */
    :root {
      --bg: #0e1012;
      --panel: #161718;
      --muted: #94a3b8;
      --accent: #10b981;
      --accent-2: #3b82f6;
      --card: #1f2224;
      --glass: rgba(255, 255, 255, 0.04);
      --danger: #ef4444;
    }

    /* --- Reset / Global --- */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html,
    body {
      height: 100%;
      width: 100%;
    }

    body {
      background: linear-gradient(180deg, var(--bg), #0b0b0b 60%);
      color: #e6eef6;
      font-family: system-ui, -apple-system, "Inter", "Segoe UI", Roboto, "Helvetica Neue", Arial;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 16px;
      gap: 16px;
    }

    /* --- Text --- */
    h1 {
      font-size: 1.2rem;
      font-weight: 600;
      color: #e6eef6;
      letter-spacing: -0.02em;
      text-align: center;
    }

    .instruction {
      color: var(--muted);
      font-size: 0.95rem;
      text-align: center;
      margin-bottom: 4px;
    }

    /* --- Layout Container --- */
    .game-frame {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 16px;
      width: 100%;
      max-width: 1200px;
    }

    /* --- Board --- */
    #board {
      width: 92vw;
      max-width: 640px;
      aspect-ratio: 1 / 1;
      background: var(--panel);
      border-radius: 10px;
      box-shadow: 0 8px 20px rgba(2, 6, 23, 0.6);
      overflow: hidden;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      transition: transform 0.2s ease-in-out;
    }

    #board:active {
      transform: scale(0.995);
    }

    .turn-indicator {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 12px;
      width: 92vw;
      max-width: 640px;
      margin: 0 auto;
      padding: 16px;
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(0, 0, 0, 0.06));
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.05);
      box-shadow: 0 4px 14px rgba(2, 6, 23, 0.4);
    }

    .selector-row {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      width: 100%;
      padding: 4px 0;
    }

    .selector-row .piece-option {
      width: 56px;
      height: 56px;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.03);
      border: 2px solid transparent;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.6rem;
      color: #dbeafe;
      cursor: pointer;
      transition: transform 0.2s ease, background 0.2s ease;
    }

    .selector-row .piece-option:hover {
      transform: translateY(-3px);
      background: rgba(255, 255, 255, 0.06);
    }

    .selector-row .piece-option.selected {
      border-color: var(--accent);
      background: rgba(16, 185, 129, 0.08);
    }

    /* Row 2 — button */
    #newBtn {
      background: linear-gradient(180deg, var(--accent-2), #2563eb);
      color: white;
      border: none;
      border-radius: 10px;
      padding: 10px 16px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.15s ease, background 0.2s ease;
      min-width: 120px;
      min-height: 44px;
      box-shadow: 0 6px 16px rgba(2, 6, 23, 0.5);
    }

    #newBtn:hover {
      transform: translateY(-3px);
    }

    /* Row 3 — feedback */
    #feedback {
      text-align: center;
      color: var(--muted);
      font-size: 0.95rem;
      min-height: 28px;
      width: 100%;
    }

    .turn-left {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .turn-badge {
      width: 44px;
      height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 8px;
      background: var(--glass);
      font-size: 1.2rem;
      color: var(--accent);
      box-shadow: 0 6px 12px rgba(2, 6, 23, 0.5);
    }

    /* --- Piece Selector --- */
    .piece-selector {
      display: flex;
      gap: 8px;
      width: 100%;
      max-width: 640px;
      overflow-x: auto;
      padding: 8px;
      -webkit-overflow-scrolling: touch;
    }

    .piece-selector::-webkit-scrollbar {
      height: 6px;
    }

    .piece-selector::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
    }

    .piece-option {
      flex: 0 0 auto;
      width: 56px;
      height: 56px;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.03);
      border: 2px solid transparent;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.6rem;
      color: #dbeafe;
      cursor: pointer;
      transition: 0.2s all;
    }

    .piece-option:hover {
      transform: translateY(-4px);
      background: rgba(255, 255, 255, 0.05);
    }

    .piece-option.selected {
      border-color: var(--accent);
      background: rgba(16, 185, 129, 0.08);
    }

    button {
      flex: 1;
      padding: 10px 4px;
      border-radius: 10px;
      background: var(--glass);
      color: #dbeafe;
      font-weight: 600;
      border: none;
      cursor: pointer;
      transition: transform 0.15s ease, background 0.2s ease;
    }

    button:hover:not(:disabled) {
      transform: translateY(-3px);
      background: rgba(255, 255, 255, 0.06);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* --- Desktop Layout --- */
    @media (min-width: 880px) {
      body {
        padding: 32px;
      }

      .game-frame {
        flex-direction: row;
        justify-content: center;
        align-items: flex-start;
        gap: 32px;
      }

      #board {
        width: clamp(640px, 48vw, 820px);
      }

      .piece-selector {
        flex-direction: column;
        width: 220px;
        max-width: 240px;
        height: auto;
        overflow: visible;
        background: var(--glass);
        border-radius: 12px;
        padding: 12px;
        border: 1px solid rgba(255, 255, 255, 0.04);
      }

      .piece-option {
        width: 64px;
        height: 64px;
        font-size: 1.8rem;
      }
    }
  </style>
</head>

<body>
  <h1>ZenChess Puzzle</h1>
  <!-- <div class="instruction">Find the missing piece that balances the position — mobile first, touch friendly.</div> -->
  <div id="feedback" aria-live="polite"></div>

  <div class="game-frame">
    <div class="game-container">
      <div id="board"></div>

      <div class="turn-indicator" role="status" aria-live="polite">
        <div class="selector-row" id="pieceOptions" role="list"></div>
        <button id="newBtn" aria-label="Load new puzzle">Next</button>

      </div>
    </div>
  </div>

  <!-- keep your module imports / URLs intact -->
  <script type="module">
    import { Chessground } from 'https://cdnjs.cloudflare.com/ajax/libs/chessground/9.2.1/chessground.min.js'
    import { Chess } from 'https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.13.4/chess.js'

    const chess = new Chess()
    let currentPuzzle = null
    let selectedPiece = null
    let hiddenPieceSquare = null
    let hiddenPieceType = null
    let currentPuzzleFenWithoutPiece = null

    const pieceSymbols = {
      'wq': '♕', 'wr': '♖', 'wb': '♗', 'wn': '♘', 'wp': '♙',
      'bq': '♛', 'br': '♜', 'bb': '♝', 'bn': '♞', 'bp': '♟'
    }

    const boardEl = document.getElementById('board')
    const newBtn = document.getElementById('newBtn')
    const feedback = document.getElementById('feedback')
    const pieceOptionsEl = document.getElementById('pieceOptions')

    // Initialize chessground board with minimal interaction (click to place via our logic)
    const board = Chessground(boardEl, {
      fen: chess.fen(),
      coordinates: true,
      highlight: { lastMove: false, check: false },
      movable: {
        free: false,
        color: undefined
      },
      events: {
        select: (square) => {
          if (selectedPiece && !chess.get(square)) {
            placePiece(square)
          }
        }
      },
      animation: { enabled: true }
    })

    function generateDecoyPieces(correctPiece) {
      const pieceTypes = ['q', 'r', 'b', 'n', 'p']
      const color = correctPiece[0] // 'w' or 'b'
      const correctType = correctPiece[1]

      // Keep your logic: return only the correct piece (you had a reason)
      return [correctPiece]
    }

    function renderPieceSelector(pieces) {
      pieceOptionsEl.innerHTML = ''
      const shuffled = [...pieces].sort(() => Math.random() - 0.5)

      shuffled.forEach(piece => {
        const option = document.createElement('button')
        option.className = 'piece-option'
        option.dataset.piece = piece
        option.setAttribute('role', 'button')
        option.setAttribute('aria-label', `Piece ${piece}`)
        option.innerText = pieceSymbols[piece] || '?'

        option.addEventListener('click', () => {
          if (option.classList.contains('selected')) {
            option.classList.remove('selected')
            selectedPiece = null 
            feedback.textContent = 'Select a piece to place'
            return
          }
          document.querySelectorAll('.piece-option').forEach(el => el.classList.remove('selected'))
          selectedPiece = piece
          option.classList.add('selected')
          feedback.textContent = `Tap an empty square on the board to place ${pieceSymbols[piece]}`
        })
        pieceOptionsEl.appendChild(option)
      })
    }

    function removePieceFromBoard(fen, square) {
      const fenParts = fen.split(' ')
      const rows = fenParts[0].split('/')

      const file = square.charCodeAt(0) - 97 // a=0, b=1, etc
      const rank = 8 - parseInt(square[1]) // 8=0, 7=1, etc

      let row = rows[rank]
      let newRow = ''
      let fileIndex = 0

      for (let char of row) {
        if (char >= '1' && char <= '8') {
          const emptySquares = parseInt(char)
          if (fileIndex + emptySquares > file && fileIndex <= file) {
            // The piece is in this empty span
            const before = file - fileIndex
            const after = emptySquares - before - 1

            if (before > 0) newRow += before.toString()
            if (after > 0) newRow += after.toString()
            else if (before === 0 && after === 0) newRow += '1'

            fileIndex += emptySquares
          } else {
            newRow += char
            fileIndex += emptySquares
          }
        } else {
          if (fileIndex === file) {
            // Replace piece with empty square
            newRow += '1'
          } else {
            newRow += char
          }
          fileIndex++
        }
      }

      // Consolidate consecutive numbers
      newRow = newRow.replace(/(\d)(\d)/g, (match, a, b) => (parseInt(a) + parseInt(b)).toString())
      rows[rank] = newRow

      fenParts[0] = rows.join('/')
      return fenParts.join(' ')
    }

    function placePiece(square) {
      if (!selectedPiece) {
        feedback.textContent = '❌ Select a piece first!'
        return
      }

      const color = selectedPiece[0] === 'w' ? 'white' : 'black'
      const pieceType = selectedPiece[1]

      // Temporarily place the piece on the board
      chess.put({ type: pieceType, color: color === 'white' ? 'w' : 'b' }, square)
      board.set({ fen: chess.fen() })

      // Wrong type
      if (selectedPiece !== hiddenPieceType) {
        feedback.textContent = `❌ Wrong piece. ${pieceSymbols[selectedPiece]} doesn't balance the position.`

        // highlight correct piece
        document.querySelectorAll('.piece-option').forEach(el => {
          if (el.dataset.piece === hiddenPieceType) el.classList.add('correct')
        })

        setTimeout(() => {
          chess.load(getCurrentPuzzleFen())
          board.set({ fen: chess.fen() })
          // clear selection but keep correct marker
          selectedPiece = null
          document.querySelectorAll('.piece-option').forEach(el => el.classList.remove('selected'))
        }, 1200)

        return
      }

      // Wrong square
      if (square !== hiddenPieceSquare) {
        feedback.textContent = '❌ Wrong square! Try again.'

        setTimeout(() => {
          chess.load(getCurrentPuzzleFen())
          board.set({ fen: chess.fen() })
          // selectedPiece = null
          // document.querySelectorAll('.piece-option').forEach(el => el.classList.remove('selected'))
        }, 1200)

        return
      }

      // Correct!
      feedback.textContent = `✅ Correct! ${pieceSymbols[selectedPiece]} on ${square} balances the position! (${currentPuzzle.eval_before}cp → ${currentPuzzle.eval_after}cp)`
      disableInteractionAfterSuccess()
    }

    function disableInteractionAfterSuccess() {
      // disable piece options
      document.querySelectorAll('.piece-option').forEach(el => {
        el.disabled = true
        el.style.opacity = '0.6'
        el.style.cursor = 'default'
      })
      // remove selection
      selectedPiece = null
    }

    function getCurrentPuzzleFen() {
      return currentPuzzleFenWithoutPiece
    }

    async function loadPuzzle() {
      try {
        newBtn.disabled = true
        feedback.textContent = 'Loading puzzle...'
        pieceOptionsEl.innerHTML = ''
        selectedPiece = null

        const res = await fetch('/api/v1/puzzles/random')
        const data = await res.json()
        console.log('Puzzle data:', data)

        if (data.results && data.results.length > 0) {
          currentPuzzle = data.results[0]

          // Parse move UCI: source (first two chars) and destination (next two)
          const move = currentPuzzle.move_uci || ''
          const sourceSquare = move.substring(0, 2)
          hiddenPieceSquare = move.substring(2, 4)

          // Load original FEN to inspect the piece at source
          chess.load(currentPuzzle.fen)
          const pieceAtSquare = chess.get(sourceSquare)

          if (!pieceAtSquare) {
            feedback.textContent = 'Error: Invalid puzzle data (no piece at source).'
            console.error('No piece found at source square:', sourceSquare)
            newBtn.disabled = false
            return
          }

          hiddenPieceType = pieceAtSquare.color + pieceAtSquare.type

          // remove the piece from the SOURCE square to create the puzzle board
          const modifiedFen = removePieceFromBoard(currentPuzzle.fen, sourceSquare)
          currentPuzzleFenWithoutPiece = modifiedFen
          chess.load(modifiedFen)

          // Update board display and reset movable settings
          board.set({
            fen: chess.fen(),
            movable: { color: undefined }
          })

          // Generate options (kept your logic)
          const pieceOptions = generateDecoyPieces(hiddenPieceType)
          renderPieceSelector(pieceOptions)

          // UI hints
          feedback.textContent = `Select the piece that belongs on the board to balance the position`
        } else {
          feedback.textContent = 'No puzzles available'
        }
      } catch (error) {
        console.error('Error loading puzzle:', error)
        feedback.textContent = 'Error loading puzzle'
      } finally {
        newBtn.disabled = false
      }
    }

    newBtn.addEventListener('click', loadPuzzle)

    // initialize on first load
    loadPuzzle()
  </script>
</body>

</html>