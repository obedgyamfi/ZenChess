<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ZenChess</title>
  <link rel="stylesheet" href="https://unpkg.com/chessground@8.3.11/assets/chessground.base.css">
  <link rel="stylesheet" href="https://unpkg.com/chessground@8.3.11/assets/chessground.brown.css">
  <link rel="stylesheet" href="https://unpkg.com/chessground@8.3.11/assets/chessground.cburnett.css">
  <style>
    body {
      margin: 0;
      padding: 20px;
      background: #1a1a1a;
      color: #fff;
      font-family: system-ui, -apple-system, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
    }

    h1 {
      margin-bottom: 1rem;
    }

    .instruction {
      margin-bottom: 2rem;
      text-align: center;
      color: #9ca3af;
      font-size: 1.1rem;
    }

    .game-container {
      display: flex;
      gap: 2rem;
      align-items: flex-start;
      margin-bottom: 1rem;
    }

    #board {
      width: 600px;
      height: 600px;
    }

    .piece-selector {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      padding: 1.5rem;
      background: #2a2a2a;
      border-radius: 8px;
      min-width: 120px;
    }

    .piece-selector h3 {
      margin: 0 0 0.5rem 0;
      text-align: center;
      font-size: 1rem;
      color: #9ca3af;
    }

    .piece-option {
      width: 80px;
      height: 80px;
      background: #3a3a3a;
      border: 3px solid transparent;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 3rem;
    }

    .piece-option:hover {
      background: #4a4a4a;
      transform: scale(1.05);
    }

    .piece-option.selected {
      border-color: #10b981;
      background: #1a3a2a;
    }

    .piece-option.correct {
      border-color: #10b981;
      background: #1a3a2a;
    }

    .buttons {
      display: flex;
      gap: 1rem;
      margin-bottom: 1rem;
    }

    button {
      padding: 0.75rem 1.5rem;
      border: none;
      border-radius: 6px;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    #newBtn {
      background: #3b82f6;
      color: white;
    }

    #newBtn:hover:not(:disabled) {
      background: #2563eb;
    }

    #feedback {
      font-size: 1.25rem;
      min-height: 30px;
      text-align: center;
    }

    .ghost-piece {
      opacity: 0.3;
    }
  </style>
</head>

<body>
  <h1>ZenChess Puzzle</h1>
  <div class="instruction">Find the missing piece that balances the position</div>

  <div class="game-container">
    <div id="board"></div>
    <div class="piece-selector">
      <h3>Select Piece</h3>
      <div id="pieceOptions"></div>
    </div>
  </div>

  <div class="buttons">
    <button id="newBtn">New Puzzle</button>
  </div>
  <div id="feedback"></div>

  <script type="module">
    import { Chessground } from 'https://cdnjs.cloudflare.com/ajax/libs/chessground/9.2.1/chessground.min.js'
    import { Chess } from 'https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.13.4/chess.js'


    const chess = new Chess()
    let currentPuzzle = null
    let selectedPiece = null
    let hiddenPieceSquare = null
    let hiddenPieceType = null

    const pieceSymbols = {
      'wq': '♕', 'wr': '♖', 'wb': '♗', 'wn': '♘', 'wp': '♙',
      'bq': '♛', 'br': '♜', 'bb': '♝', 'bn': '♞', 'bp': '♟'
    }

    const board = Chessground(document.getElementById('board'), {
      fen: chess.fen(),
      coordinates: true,
      movable: {
        free: false,
        color: undefined
      },
      events: {
        select: (square) => {
          if (selectedPiece && !chess.get(square)) {
            placePiece(square)
          }
        }
      }
    })

    const newBtn = document.getElementById('newBtn')
    const feedback = document.getElementById('feedback')
    const pieceOptionsEl = document.getElementById('pieceOptions')

    function generateDecoyPieces(correctPiece) {
      const pieceTypes = ['q', 'r', 'b', 'n', 'p']
      const color = correctPiece[0] // 'w' or 'b'
      const correctType = correctPiece[1]

      // Remove correct piece type
      const availableTypes = pieceTypes.filter(t => t !== correctType)

      // Pick one random decoy
      const decoyType = availableTypes[Math.floor(Math.random() * availableTypes.length)]

      // return [correctPiece, color + decoyType]
      return [correctPiece]
    }

    function renderPieceSelector(pieces) {
      pieceOptionsEl.innerHTML = ''

      // Shuffle pieces for display
      const shuffled = [...pieces].sort(() => Math.random() - 0.5)

      shuffled.forEach(piece => {
        const option = document.createElement('div')
        option.className = 'piece-option'
        option.dataset.piece = piece
        option.textContent = pieceSymbols[piece]

        option.addEventListener('click', () => {
          // Remove previous selection
          document.querySelectorAll('.piece-option').forEach(el => {
            el.classList.remove('selected')
          })

          selectedPiece = piece
          option.classList.add('selected')
          feedback.textContent = `Click on the board to place the ${pieceSymbols[piece]}`
        })

        pieceOptionsEl.appendChild(option)
      })
    }

    function removePieceFromBoard(fen, square) {
      const fenParts = fen.split(' ')
      const rows = fenParts[0].split('/')

      const file = square.charCodeAt(0) - 97 // a=0, b=1, etc
      const rank = 8 - parseInt(square[1]) // 8=0, 7=1, etc

      let row = rows[rank]
      let newRow = ''
      let fileIndex = 0

      for (let char of row) {
        if (char >= '1' && char <= '8') {
          const emptySquares = parseInt(char)
          if (fileIndex + emptySquares > file && fileIndex <= file) {
            // The piece is in this empty span
            const before = file - fileIndex
            const after = emptySquares - before - 1

            if (before > 0) newRow += before.toString()
            if (after > 0) newRow += after.toString()
            else if (before === 0 && after === 0) newRow += '1'

            fileIndex += emptySquares
          } else {
            newRow += char
            fileIndex += emptySquares
          }
        } else {
          if (fileIndex === file) {
            // Replace piece with empty square
            newRow += '1'
          } else {
            newRow += char
          }
          fileIndex++
        }
      }

      // Consolidate consecutive numbers
      newRow = newRow.replace(/(\d)(\d)/g, (match, a, b) => (parseInt(a) + parseInt(b)).toString())
      rows[rank] = newRow

      fenParts[0] = rows.join('/')
      return fenParts.join(' ')
    }

    function placePiece(square) {
      if (!selectedPiece) {
        feedback.textContent = '❌ Select a piece first!'
        return
      }

      const color = selectedPiece[0] === 'w' ? 'white' : 'black'
      const pieceType = selectedPiece[1]

      // Place the piece on the board to show it
      chess.put({ type: pieceType, color: color === 'white' ? 'w' : 'b' }, square)
      board.set({ fen: chess.fen() })

      // Check if it's the correct piece type
      if (selectedPiece !== hiddenPieceType) {
        feedback.textContent = `❌ Wrong piece! The ${pieceSymbols[selectedPiece]} doesn't balance the position.`

        // Highlight correct piece
        document.querySelectorAll('.piece-option').forEach(el => {
          if (el.dataset.piece === hiddenPieceType) {
            el.classList.add('correct')
          }
        })

        // Reset board after delay
        setTimeout(() => {
          chess.load(getCurrentPuzzleFen())
          board.set({ fen: chess.fen() })
        }, 1500)

        return
      }

      // Check if it's the correct square
      if (square !== hiddenPieceSquare) {
        feedback.textContent = '❌ Wrong square! Try again.'

        // Reset board after delay
        setTimeout(() => {
          chess.load(getCurrentPuzzleFen())
          board.set({ fen: chess.fen() })
        }, 1500)

        return
      }

      // Correct! Keep the piece on the board
      feedback.textContent = `✅ Correct! ${pieceSymbols[selectedPiece]} on ${square} balances the position! (${currentPuzzle.eval_before}cp → ${currentPuzzle.eval_after}cp)`

      // Disable further interaction
      selectedPiece = null
      document.querySelectorAll('.piece-option').forEach(el => {
        el.style.cursor = 'default'
        el.style.opacity = '0.5'
      })
    }

    // Helper to get the current puzzle FEN without the hidden piece
    let currentPuzzleFenWithoutPiece = null

    // Update in loadPuzzle() after removing the piece:
    // currentPuzzleFenWithoutPiece = modifiedFen

    function getCurrentPuzzleFen() {
      return currentPuzzleFenWithoutPiece
    }

    async function loadPuzzle() {
      try {
        newBtn.disabled = true
        feedback.textContent = 'Loading puzzle...'
        pieceOptionsEl.innerHTML = ''
        selectedPiece = null

        const res = await fetch('/api/v1/puzzles/random')
        const data = await res.json()

        console.log('Puzzle data:', data)

        if (data.results && data.results.length > 0) {
          currentPuzzle = data.results[0]

          // Parse the move to get source and destination
          const move = currentPuzzle.move_uci
          const sourceSquare = move.substring(0, 2) // e.g., "g5e3" -> "g5"
          hiddenPieceSquare = move.substring(2, 4) // e.g., "g5e3" -> "e3"

          // Load the position and get the piece at SOURCE square
          chess.load(currentPuzzle.fen)
          const pieceAtSquare = chess.get(sourceSquare)

          if (!pieceAtSquare) {
            feedback.textContent = 'Error: Invalid puzzle data (no piece at source)'
            console.error('No piece found at source square:', sourceSquare)
            return
          }

          hiddenPieceType = pieceAtSquare.color + pieceAtSquare.type

          // Remove the piece from the SOURCE square
          const modifiedFen = removePieceFromBoard(currentPuzzle.fen, sourceSquare)
          currentPuzzleFenWithoutPiece = modifiedFen
          chess.load(modifiedFen)

          // Update board display
          board.set({
            fen: chess.fen(),
            movable: { color: undefined }
          })

          // Generate piece options (correct + 1 decoy)
          const pieceOptions = generateDecoyPieces(hiddenPieceType)
          renderPieceSelector(pieceOptions)

          feedback.textContent = `Select the piece that belongs on the board to balance the position`
        } else {
          feedback.textContent = 'No puzzles available'
        }
      } catch (error) {
        console.error('Error loading puzzle:', error)
        feedback.textContent = 'Error loading puzzle'
      } finally {
        newBtn.disabled = false
      }
    }

    newBtn.addEventListener('click', loadPuzzle)

    loadPuzzle()
  </script>
</body>

</html>